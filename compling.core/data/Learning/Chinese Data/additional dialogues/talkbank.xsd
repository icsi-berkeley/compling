<?xml version="1.0" encoding="UTF-8"?>

<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns="http://www.talkbank.org/ns/talkbank" targetNamespace="http://www.talkbank.org/ns/talkbank"
  elementFormDefault="qualified" attributeFormDefault="unqualified" version="1.1.3" id="Talkbank">
  <xs:annotation>
    <xs:documentation> This version of XML schema has been adapted by Eva Mok for use in a
      computational language learning model. Main changes include: i) numbering of utterances
      (subsumed by newer releases of the schemas available at the XML talkbank) ii) utterances split
      into clauses at pauses iii) elaboration of entities present in the environment and their
      attributes iv) allowing the enumeration of the initial setting at the start of the transcript
      v) allowing the annotation of events using the "e" tag designed specifically for the learning
      model </xs:documentation>
    <xs:documentation> The current version defines two types of documents: the global elements
      below... The global types are available for reusing through schema type extension/restriction.
      The most up to date document definition is CHAT, it is also the richest in structure. Ideally,
      each group should develop a schema module defining the structure of their specific (class of)
      annotations, this schema should be an assembly of their definitions. </xs:documentation>
    <xs:documentation> Developed by Romeo Anghelache, from the CHAT specifications, released under
      the GNU Public License, 2001. Continuing development by Franklin Chen. </xs:documentation>
  </xs:annotation>

  <xs:element name="CHAT">
    <xs:complexType mixed="false">
      <xs:annotation> </xs:annotation>
      <xs:sequence>
        <xs:element name="Metadata" type="Metadata" minOccurs="0"/>
        <xs:element name="comment" type="commentType" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element name="Participants">
          <xs:annotation>
            <!--fmc rid initial space? -->
            <xs:documentation> @Participants; a structure enumerating the beings
            participating</xs:documentation>
          </xs:annotation>
          <!-- fmc does this need to be in a sequence? -->
          <xs:complexType>
            <xs:sequence>
              <xs:element name="participant" type="participantType" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        
        <xs:element name="Setting" minOccurs="0" maxOccurs="1">
          <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
              <xs:element name="binding" type="bindingType" maxOccurs="unbounded"/>
              <xs:element name="entity" type="entityType" maxOccurs="unbounded"/>              
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name="Setup" minOccurs="0">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="binding" type="bindingType" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
                
        <!-- MUN: Added 'minOccurs="0"' -->
        <xs:choice maxOccurs="unbounded" minOccurs="0">
          <xs:element name="comment" type="commentType"/>
          <xs:element name="tcu" type="tcuType"/>
          <!-- fmc need constraints on all the gems -->
          <xs:element name="begin-gem">
            <xs:complexType>
              <xs:attribute name="label" type="xs:string" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="end-gem">
            <xs:complexType>
              <xs:attribute name="label" type="xs:string" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="lazy-gem">
            <xs:complexType>
              <xs:attribute name="label" type="xs:string" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="u" type="speakerUtteranceType"/>
          <xs:element name="event" type="entityType"/>
        </xs:choice>
        
        
        <!--fmc
        <xs:element name="media" type="mediaType" minOccurs="0"/>
        -->

        
      </xs:sequence>
      
    
      
      <xs:attribute name="Id" type="xs:string" use="required"/>
      <xs:attribute name="Version">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:pattern value="1.1.[0-9]{1,}"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="Date" type="xs:date" use="required">
        <xs:annotation>
          <xs:documentation> 31 March 1999 is formatted as 1999-03-31</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="Duration" type="xs:duration" use="optional">
        <xs:annotation>
          <xs:documentation> this work might be done in an extended interval of time; a duration of
            1 year, 2 months, 3 days, 10 hours, and 30 minutes, one would write:
          P1Y2M3DT10H30M</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <!--fmc which of these are actually created when parsing CHAT? -->
      <xs:attribute name="Coder" type="xs:string"/>
      <!--fmc
      <xs:attribute name="Comment" type="xs:string"/>
-->
      <xs:attribute name="Situation" type="xs:string"/>
      <xs:attribute name="Corpus" type="xs:string" use="required"/>

      <!-- CA or not -->
      <xs:attribute name="Mode" type="xs:string"/>
      <!--fmc
      <xs:attribute name="Media" type="xs:anyURI"/>
-->
      <xs:attribute name="Lang" type="languageType" use="required"/>
      <xs:attribute name="Script" type="languageType">
        <xs:annotation>
          <xs:documentation> e.g. when you write russian words using english characters, then
            Lang="ru" and Script is "en"</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="Warning" type="xs:string"/>
      <xs:attribute name="Colorwords" type="xs:string"/>
    </xs:complexType>
  </xs:element>


  <xs:element name="AGSet">
    <xs:complexType>
      <xs:annotation>
        <xs:documentation> an AIF document, see http://morph.ldc.upenn.edu/AG/doc/xml/
        </xs:documentation>
      </xs:annotation>
      <xs:sequence>
        <xs:element name="Metadata" type="Metadata"/>
        <xs:element name="Timeline" minOccurs="0" maxOccurs="unbounded">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="Metadata" type="Metadata" minOccurs="0"/>
              <xs:element name="Signal" minOccurs="0" maxOccurs="unbounded">
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="Metadata" type="Metadata" minOccurs="0"/>
                  </xs:sequence>
                  <xs:attribute name="id" type="xs:ID" use="required"/>
                  <xs:attribute name="mimeClass" type="xs:string" use="required"/>
                  <xs:attribute name="mimeType" type="xs:string" use="required"/>
                  <xs:attribute name="encoding" type="xs:string" use="required"/>
                  <xs:attribute name="unit" type="xs:string" use="required"/>
                  <xs:attribute name="href" type="xs:string" use="required"/>
                  <xs:attribute name="track" type="xs:NMTOKEN"/>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
            <xs:attribute name="id" type="xs:ID" use="required"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="AG" minOccurs="0" maxOccurs="unbounded">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="Metadata" type="Metadata" minOccurs="0"/>
              <xs:element name="Anchor" minOccurs="0" maxOccurs="unbounded">
                <xs:complexType>
                  <xs:attribute name="id" type="xs:ID" use="required"/>
                  <xs:attribute name="offset" type="xs:string"/>
                  <xs:attribute name="unit" type="xs:string"/>
                  <xs:attribute name="signals" type="xs:IDREFS"/>
                </xs:complexType>
              </xs:element>
              <xs:element name="Annotation" minOccurs="0" maxOccurs="unbounded">
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="Feature" minOccurs="0" maxOccurs="unbounded">
                      <xs:complexType>
                        <xs:simpleContent>
                          <xs:extension base="xs:string">
                            <xs:attribute name="name" type="xs:NMTOKEN" use="required"/>
                          </xs:extension>
                        </xs:simpleContent>
                      </xs:complexType>
                    </xs:element>
                  </xs:sequence>
                  <xs:attribute name="id" type="xs:ID" use="required"/>
                  <xs:attribute name="type" type="xs:NMTOKEN" use="required"/>
                  <xs:attribute name="start" type="xs:IDREF" use="required"/>
                  <xs:attribute name="end" type="xs:IDREF" use="required"/>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
            <xs:attribute name="id" type="xs:ID" use="required"/>
            <xs:attribute name="type" type="xs:NMTOKEN"/>
            <xs:attribute name="timeline" type="xs:IDREF"/>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
      <xs:attribute name="id" type="xs:ID" use="required"/>
      <xs:attribute name="version" type="xs:string" fixed="1.0"/>
    </xs:complexType>
  </xs:element>


  <xs:complexType name="Metadata">
    <xs:annotation>
      <xs:documentation>administrative descriptions, reused from Dublin Core</xs:documentation>
    </xs:annotation>
    <xs:group ref="DCelementsGroup"/>
  </xs:complexType>


  <!--fmc tighten up? -->
  <xs:complexType name="shorteningType">
    <xs:annotation>
      <xs:documentation> () in a word</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="nonemptyStringType"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="precodeType">
    <xs:annotation>
      <xs:documentation>precode at the beginning of an utterance; CHAT [- ...]</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="nonemptyStringType"/>
    </xs:simpleContent>
  </xs:complexType>

  <!--fmc for now, no type to content; just string-->
  <xs:complexType name="freecodeType">
    <xs:annotation>
      <xs:documentation>unscoped code in the middle of an utterance; CHAT {...}</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="nonemptyStringType"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="postcodeType">
    <xs:annotation>
      <xs:documentation>postcode at the end of an utterance; CHAT [+ ...]</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="nonemptyStringType"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="annotationType" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="media" type="mediaType"/>
      <xs:element name="binding" type="bindingType"/>
      <xs:element name="sa" type="entityType"/>
      <xs:element name="constructional" type="goldstandardConstructionalType"/>
      <xs:element name="semantic" type="goldstandardSemanticType"/>
    </xs:choice>

    <xs:attribute name="lang" type="languageType"/>
    <xs:attribute name="script" type="languageType"/>
    <!--fmc this is a hack-->
    <xs:attribute name="flavor" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation> allows semi structured extensions to the current set of annotations:
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="annotationTypeType"/>
  </xs:complexType>


  <xs:complexType name="commentType" mixed="true">
    <xs:sequence>
      <xs:element name="media" type="mediaType" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="type">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="Activities"/>
          <xs:enumeration value="Bck"/>
          <xs:enumeration value="Coder"/>
          <xs:enumeration value="Coding"/>
          <xs:enumeration value="Date"/>
          <xs:enumeration value="Education"/>
          <xs:enumeration value="Exceptions"/>
          <xs:enumeration value="Generic"/>
          <!-- Added 3-31-05 -->
          <xs:enumeration value="Code"/>
          <xs:enumeration value="New Language"/>
          <xs:enumeration value="Location"/>
          <xs:enumeration value="New Episode"/>
          <xs:enumeration value="Page"/>
          <xs:enumeration value="Pause"/>
          <xs:enumeration value="Room Layout"/>
          <xs:enumeration value="Script"/>
          <xs:enumeration value="Situation"/>
          <!--
              <xs:enumeration value="Stim"/>
-->
          <xs:enumeration value="Tape Location"/>
          <xs:enumeration value="Time Duration"/>
          <xs:enumeration value="Time Start"/>
          <!--
              <xs:enumeration value="Transcriber"/>
-->
          <xs:enumeration value="Warning"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>


  <xs:complexType name="markers" mixed="false">
    <xs:annotation>
      <xs:documentation>inlined annotations, the conventional CHAT symbols are listed
      too</xs:documentation>
    </xs:annotation>
    <xs:sequence minOccurs="0">
      <xs:element name="media" type="mediaType"/>
    </xs:sequence>
    <xs:attribute name="lang" type="languageType"/>
    <xs:attribute name="script" type="languageType"/>
    <xs:attribute name="times" type="xs:positiveInteger" use="optional"/>
    <xs:attribute name="type" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="stressing">
            <xs:annotation>
              <xs:documentation> [!]</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="contrastive stressing">
            <xs:annotation>
              <xs:documentation> [!!]</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="quotation">
            <xs:annotation>
              <xs:documentation> ["]</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="best guess">
            <xs:annotation>
              <xs:documentation> [?] in CHAT, ( text ) in CA</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="retracing">
            <xs:annotation>
              <xs:documentation> [/] in CHAT</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="retracing with correction">
            <xs:annotation>
              <xs:documentation> [//] in CHAT, - in CA</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="retracing reformulation">
            <xs:annotation>
              <xs:documentation> [///] in CHAT</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="retracing unclear">
            <xs:annotation>
              <xs:documentation> [/?]</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="false start">
            <xs:annotation>
              <xs:documentation> [/-]</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="allegro">
            <xs:annotation>
              <xs:documentation> quicker tempo, no CHAT equivalent, used in CA</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="lento">
            <xs:annotation>
              <xs:documentation> slower tempo, no CHAT equivalent, used in CA</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="forte">
            <xs:annotation>
              <xs:documentation> larger volume, louder, no CHAT equivalent, used in
              CA</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="piano">
            <xs:annotation>
              <xs:documentation> lower volume, no CHAT equivalent, used in CA</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <!-- fmc extracted out
          <xs:enumeration value="overlap follows">
            <xs:annotation>
              <xs:documentation> [&gt;]</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="overlap precedes">
            <xs:annotation>
              <xs:documentation> [&lt;]</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
-->
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="overlapPointType" mixed="false">
    <xs:annotation>
      <xs:documentation>CA-style overlap</xs:documentation>
    </xs:annotation>
    <xs:attribute name="index" type="xs:positiveInteger" use="optional"/>
    <xs:attribute name="start-end" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="start">
            <xs:annotation>
              <xs:documentation> fmc </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="end">
            <xs:annotation>
              <xs:documentation> fmc </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="top-bottom" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="top">
            <xs:annotation>
              <xs:documentation> fmc </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="bottom">
            <xs:annotation>
              <xs:documentation> fmc </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="overlapType" mixed="false">
    <xs:annotation>
      <xs:documentation>mark overlap scoping</xs:documentation>
    </xs:annotation>
    <xs:attribute name="index" type="xs:positiveInteger" use="optional"/>
    <xs:attribute name="type" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="overlap follows">
            <xs:annotation>
              <xs:documentation> [&gt;]</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="overlap precedes">
            <xs:annotation>
              <xs:documentation> [&lt;]</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>

  <!-- If no string content, then means [*] -->
  <xs:simpleType name="errorType">
    <xs:annotation>
      <xs:documentation>[*] or [* text]</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string"/>
  </xs:simpleType>

  <xs:complexType name="tagMarkerType">
    <xs:annotation>
      <xs:documentation>,, for %mor</xs:documentation>
    </xs:annotation>
  </xs:complexType>

  <xs:complexType name="errType">
    <xs:annotation>
      <xs:documentation>For %mor</xs:documentation>
    </xs:annotation>
  </xs:complexType>

  <xs:element name="tagMarker" type="tagMarkerType"/>
  <xs:element name="err" type="errType"/>

  <!-- mixed in order to allow content -->
  <xs:complexType name="eventType" mixed="true">
    <xs:annotation>
      <xs:documentation>non verbal happenings</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="x" type="translation"/>
        <xs:element name="k" type="markers">
          <xs:annotation>
            <xs:documentation>scoped symbols</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="error" type="errorType"/>
        <xs:element name="overlap" type="overlapType"/>
        <xs:element name="r" type="repetitionType"/>
        <xs:element name="a" type="annotationType">
          <xs:annotation>
            <xs:documentation>the place to add research content</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="tone" type="toneType"/>
      </xs:choice>
      <xs:element name="media" type="mediaType" minOccurs="0"/>
    </xs:sequence>

    <xs:attribute name="type">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <!-- Items without content -->
          <!--fmc moved to word
          <xs:enumeration value="unintelligible-word">
            <xs:annotation>
              <xs:documentation> xx</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="unintelligible-word-with-pho">
            <xs:annotation>
              <xs:documentation> yy</xs:documentation>
            </xs:annotation>
              </xs:enumeration>
          <xs:enumeration value="unintelligible">
            <xs:annotation>
              <xs:documentation> xxx </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="unintelligible-with-pho">
            <xs:annotation>
              <xs:documentation> yyy </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="untranscribed">
            <xs:annotation>
              <xs:documentation> www</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
-->
          <xs:enumeration value="action">
            <xs:annotation>
              <xs:documentation> 0</xs:documentation>
            </xs:annotation>
          </xs:enumeration>

          <!--fmc items with content; should really move out-->
          <xs:enumeration value="omission">
            <xs:annotation>
              <xs:documentation> 0word</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="incorrect omission">
            <xs:annotation>
              <xs:documentation> 0*word</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="ellipsis">
            <xs:annotation>
              <xs:documentation> 00word</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="fragment">
            <xs:annotation>
              <xs:documentation> &amp;; phonological fragment</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="happening">
            <xs:annotation>
              <xs:documentation> &amp;=; happening, such as sneeze</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>


  <xs:complexType name="formType" mixed="true">
    <xs:annotation>
      <xs:documentation> intended as a feature of a word, see also the CHAT conventional
      notations</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="p" type="prosodyType" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="media" type="mediaType" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="type">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="approximation">
            <xs:annotation>
              <xs:documentation> @ap</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="babbling">
            <xs:annotation>
              <xs:documentation> @b</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="child-invented">
            <xs:annotation>
              <xs:documentation> @c</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="cue">
            <xs:annotation>
              <xs:documentation> @cue</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="dialect">
            <xs:annotation>
              <xs:documentation> @d</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="family-specific">
            <xs:annotation>
              <xs:documentation> @f</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="filled pause">
            <xs:annotation>
              <xs:documentation> @fp</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="generic">
            <xs:annotation>
              <xs:documentation> @g</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="interjection">
            <xs:annotation>
              <xs:documentation> @i</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="informal sign">
            <xs:annotation>
              <xs:documentation> @inf</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="informal sign with speech">
            <xs:annotation>
              <xs:documentation> @ins</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="kana">
            <xs:annotation>
              <xs:documentation> @k</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="letter">
            <xs:annotation>
              <xs:documentation> @l</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="motherese">
            <xs:annotation>
              <xs:documentation> @m</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="neologism">
            <xs:annotation>
              <xs:documentation> @n</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="no voice">
            <xs:annotation>
              <xs:documentation> @nv</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="onomatopoeia">
            <xs:annotation>
              <xs:documentation> @o</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="phonology consistent">
            <xs:annotation>
              <xs:documentation> @p</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="phrasal repetition">
            <xs:annotation>
              <xs:documentation> @pr</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="plural">
            <xs:annotation>
              <xs:documentation> -s</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="quoted metareference">
            <xs:annotation>
              <xs:documentation> @q</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="second language">
            <xs:annotation>
              <xs:documentation> @s</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="schwa">
            <xs:annotation>
              <xs:documentation> @sc</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="sign speech">
            <xs:annotation>
              <xs:documentation> @sas</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="singing">
            <xs:annotation>
              <xs:documentation> @si</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="signed language">
            <xs:annotation>
              <xs:documentation> @sl</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="test">
            <xs:annotation>
              <xs:documentation> @t</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="UNIBET">
            <xs:annotation>
              <xs:documentation> @u</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="words to be excluded">
            <xs:annotation>
              <xs:documentation> @x</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="word play">
            <xs:annotation>
              <xs:documentation> @wp</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>


  <xs:simpleType name="nonemptyStringType">
    <xs:annotation>
      <xs:documentation> a nonempty string</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:minLength value="1"/>
    </xs:restriction>
  </xs:simpleType>


  <xs:simpleType name="languageType">
    <xs:annotation>
      <xs:documentation> temporary hack till we define language better, possibly using XML language
        type</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:minLength value="1"/>
    </xs:restriction>
  </xs:simpleType>


  <xs:complexType name="syntactic" mixed="true">
    <xs:annotation>
      <xs:documentation> syntactic structure</xs:documentation>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="AGR" type="nonemptyStringType"/>
      <xs:element name="CAT" type="nonemptyStringType"/>
      <xs:element name="COUNTER" type="nonemptyStringType"/>
      <xs:element name="DUMMY" type="nonemptyStringType"/>
      <xs:element name="ELLIPSIS" type="nonemptyStringType"/>
      <xs:element name="INDEX" type="nonemptyStringType"/>
      <xs:element name="MODAL" type="nonemptyStringType"/>
      <xs:element name="MOOD" type="nonemptyStringType"/>
      <xs:element name="NEGATION" type="nonemptyStringType"/>
      <xs:element name="NUM" type="nonemptyStringType"/>
      <xs:element name="POSS" type="nonemptyStringType"/>
      <xs:element name="REL-PRO" type="syntactic"/>
      <xs:element name="ROOT" type="nonemptyStringType"/>
      <xs:element name="VFORM" type="nonemptyStringType"/>
      <xs:element name="SUBCAT" type="nonemptyStringType"/>
      <xs:element name="ADJUNCT" type="syntactic"/>
      <xs:element name="AUX" type="syntactic"/>
      <xs:element name="COMMUNICATOR" type="syntactic"/>
      <xs:element name="COMP" type="syntactic"/>
      <xs:element name="CONJ" type="syntactic"/>
      <xs:element name="DET" type="syntactic"/>
      <xs:element name="INF-PARTICLE" type="syntactic"/>
      <xs:element name="MULTIPLE" type="syntactic"/>
      <xs:element name="MODIFIER" type="syntactic"/>
      <xs:element name="OBJECT" type="syntactic"/>
      <xs:element name="PP-OBJ" type="syntactic"/>
      <xs:element name="PREDICATE" type="syntactic"/>
      <xs:element name="POSSESSOR" type="syntactic"/>
      <xs:element name="QUANTIFIER" type="syntactic"/>
      <xs:element name="QUANT" type="syntactic"/>
      <xs:element name="QUANT1" type="syntactic"/>
      <xs:element name="QUANT2" type="syntactic"/>
      <xs:element name="RECIPIENT" type="syntactic"/>
      <xs:element name="RELATIVE-CLAUSE" type="syntactic"/>
      <xs:element name="SUBJ" type="syntactic"/>
      <xs:element name="TAG-AUX" type="syntactic"/>
      <xs:element name="TAG-PRO" type="syntactic"/>
      <xs:element name="TITLE" type="syntactic"/>
      <xs:element name="XCOMP" type="syntactic"/>
      <xs:element name="VOCATIVE" type="syntactic"/>
    </xs:choice>
  </xs:complexType>

  <xs:complexType name="morphemicWordType" mixed="false">
    <xs:annotation>
      <xs:documentation>the unit of a %mor line corresponding to a word (this element belongs to a
        word element, but, if the precise correspondence is not yet established, these elements will
        be present at the utterance level (contained in an utterance);</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <!--fmc should be in mpfx-->
      <xs:element ref="err" minOccurs="0"/>
      <xs:element name="mpfx" type="morphemicPrefixType" minOccurs="0" maxOccurs="unbounded"/>

      <xs:element name="pos" type="posType"/>
      <xs:element name="stem">
        <xs:complexType mixed="true">
          <xs:all>
            <!--fmc?-->
            <xs:element ref="err" minOccurs="0"/>
          </xs:all>
        </xs:complexType>
      </xs:element>
      <!--fmc should be in mk-->
      <xs:element ref="err" minOccurs="0"/>
      <xs:element name="menx" type="morphemicTranslationType" minOccurs="0"/>
      <!--fmc suffix-->
      <xs:element name="mk" type="morphemic_marker" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="posType" mixed="false">
    <xs:annotation>
      <xs:documentation>%mor part of speech</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <!--fmc should be an attribute-->
      <xs:element ref="err" minOccurs="0"/>
      <!--fmc should be an attribute-->
      <xs:element name="omitted" minOccurs="0">
        <xs:annotation>
          <xs:documentation>omitted, CHAT equivalent is 0</xs:documentation>
        </xs:annotation>
        <xs:complexType/>
      </xs:element>
      <xs:element name="c" type="xs:string">
        <xs:annotation>
          <xs:documentation>category</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="s" type="xs:string" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>subcategory</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>


  <!-- Note mwn instead of wn to avoid confusion -->
  <xs:complexType name="morphemicsType" mixed="false">
    <xs:annotation>
      <xs:documentation>a %mor or %trn line</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="mwa" type="morphemicAlternativeType"/>
        <xs:element name="mwn" type="morphemicGroupType"/>
        <xs:element ref="tagMarker"/>
        <xs:element name="error" type="errorType"/>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="lang" type="languageType"/>
    <xs:attribute name="script" type="languageType"/>
  </xs:complexType>

  <xs:complexType name="morphemicAlternativeType" mixed="false">
    <xs:annotation>
      <xs:documentation>two or more alternate morphemic groups; CHAT ^</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="mwn" type="morphemicGroupType" minOccurs="2" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <!-- Note mw instead of w to avoid confusion -->
  <xs:complexType name="morphemicGroupType" mixed="false">
    <xs:annotation>
      <xs:documentation>a group of words in %mor</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="mwg"/>
      <xs:sequence minOccurs="0" maxOccurs="unbounded">
        <xs:element name="cli" type="morCliticType"/>
        <xs:element ref="mwg"/>
      </xs:sequence>
    </xs:sequence>
  </xs:complexType>

  <xs:element name="mwg" type="morphemicWordsGroup"/>

  <xs:complexType name="morphemicWordsGroup">
    <xs:annotation>
      <xs:documentation>a single word or a compound word</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="mw" type="morphemicWordType"/>
      <xs:sequence>
        <!--fmc should disambiguate from word-level pos-->
        <xs:element name="pos" type="posType"/>

        <xs:element name="mw" type="morphemicWordType"/>

        <xs:sequence minOccurs="1" maxOccurs="unbounded">
          <xs:element name="comp" type="morphemicCompoundType"/>
          <xs:element name="mw" type="morphemicWordType"/>
        </xs:sequence>
      </xs:sequence>
    </xs:choice>
  </xs:complexType>

  <!--fmc why is everything not a word net?-->
  <xs:complexType name="wordnetType" mixed="false">
    <xs:annotation>
      <xs:documentation>a construct formed by words linked through clitic or compound e.g.
        once+and+for+all</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <!--fmc this is not right:  should have a bare word type-->
      <xs:element name="w" type="wordType"/>
      <xs:sequence maxOccurs="unbounded">
        <xs:element name="wk" type="wordnetMarkerType"/>
        <xs:choice>
          <xs:element name="w" type="wordType"/>
          <xs:element name="e" type="eventType"/>
        </xs:choice>
      </xs:sequence>
      <xs:element name="f" type="formType" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>equivalent of CHAT symbol @;</xs:documentation>
        </xs:annotation>
      </xs:element>

      <xs:choice maxOccurs="unbounded">
        <xs:element name="tone" type="toneType"/>
        <xs:element name="a" type="annotationType">
          <xs:annotation>
            <xs:documentation>the place to add research content</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="k" type="markers">
          <xs:annotation>
            <xs:documentation>scoped symbols</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="error" type="errorType"/>
        <xs:element name="overlap" type="overlapType"/>
        <xs:element name="r" minOccurs="0"/>
        <xs:element name="x" type="translation" minOccurs="0"/>
        <xs:element name="mk" type="morphemic_marker" minOccurs="0">
          <xs:annotation>
            <xs:documentation> an optional suffix</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="media" type="mediaType" minOccurs="0"/>
      </xs:choice>

    </xs:sequence>
    <xs:attribute name="who" type="xs:string"/>
    <!--fmc for burger-->
    <xs:attribute name="lang" type="languageType"/>
  </xs:complexType>


  <xs:complexType name="toneType" mixed="false">
    <xs:annotation>
      <xs:documentation>nonfinal tone marker</xs:documentation>
    </xs:annotation>
    <xs:attribute name="type">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="level nonfinal">
            <xs:annotation>
              <xs:documentation> -,</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="falling nonfinal">
            <xs:annotation>
              <xs:documentation> -_</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="rising nonfinal">
            <xs:annotation>
              <xs:documentation> -'</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="low level">
            <xs:annotation>
              <xs:documentation> -</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="tag question">
            <xs:annotation>
              <xs:documentation> ,,</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="lengthened">
            <xs:annotation>
              <xs:documentation> -:</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>


  <xs:complexType name="groupType" mixed="false">
    <xs:annotation>
      <xs:documentation>structure used to let annotations to belong to more than one word, can be
        recursive, although unnecessary: one can attach more than one annotations to a word, group
        of words, or whole utterances</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice maxOccurs="unbounded">
        <xs:element name="g" type="groupType"/>
        <xs:element name="w" type="wordType"/>
        <xs:element name="wn" type="wordnetType"/>
        <!--fmc Unique Particle Attribution violation
        <xs:element name="tone" type="toneType"/>
-->
        <xs:element name="pause" type="pauseType"/>
        <xs:element name="freecode" type="freecodeType"/>
        <xs:element name="e" type="eventType">
          <xs:annotation>
            <xs:documentation>a reference to a point/portion of a mute/action signal, e.g. 0
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <!-- Not really a separator -->
        <xs:element name="s" type="separatorType" minOccurs="0">
          <xs:annotation>
            <xs:documentation>semicolon , clause delimiter [^c]; </xs:documentation>
          </xs:annotation>
        </xs:element>

        <xs:element ref="long-feature"/>
        <xs:element ref="nonvocal"/>
        <xs:element name="overlap-point" type="overlapPointType"/>
        <xs:element ref="underline"/>
        <xs:element ref="italic"/>
        <xs:element ref="bold"/>
      </xs:choice>

      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="tone" type="toneType"/>
        <xs:element name="k" type="markers" minOccurs="0">
          <xs:annotation>
            <xs:documentation>scoped symbols</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="error" type="errorType"/>
        <xs:element name="overlap" type="overlapType"/>
        <xs:element name="r" type="repetitionType"/>
        <xs:element name="a" type="annotationType">
          <xs:annotation>
            <xs:documentation>the place to add research content</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="x" type="translation"/>
      </xs:choice>

      <xs:element name="media" type="mediaType" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="who" type="xs:string"/>
  </xs:complexType>


  <xs:complexType name="wordType" mixed="true">
    <xs:annotation>
      <xs:documentation>a word</xs:documentation>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="overlap-point" type="overlapPointType"/>
      <xs:element ref="underline"/>
      <xs:element ref="italic"/>
      <xs:element ref="bold"/>
      <xs:element name="shortening" type="shorteningType"/>
      <xs:element name="p" type="prosodyType"/>

      <!-- For CA -->
      <xs:element ref="long-feature"/>
      <xs:element name="pitch-up"/>
      <xs:element name="pitch-down"/>
      <xs:element name="inhalation"/>
      <xs:element name="no-break"/>

      <!--fmc should this be only at the end?-->
      <xs:element name="f" type="formType">
        <xs:annotation>
          <xs:documentation>equivalent of CHAT symbol @; </xs:documentation>
        </xs:annotation>
      </xs:element>

      <!--fmc what's this mor stuff?-->
      <xs:element name="mor" type="morphemicsType"/>
      <xs:element name="trn" type="morphemicsType"/>
      <xs:element name="tone" type="toneType"/>
      <xs:element name="a" type="annotationType">
        <xs:annotation>
          <xs:documentation>the place to add research content</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="k" type="markers">
        <xs:annotation>
          <xs:documentation>scoped symbols</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="error" type="errorType"/>
      <xs:element name="overlap" type="overlapType"/>
      <xs:element name="r" type="repetitionType"/>
      <xs:element name="x" type="translation"/>
      <xs:element name="mk" type="morphemic_marker">
        <xs:annotation>
          <xs:documentation> an optional suffix</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="media" type="mediaType"/>
    </xs:choice>
    <xs:attribute name="who" type="xs:string"/>
    <xs:attribute name="lang" type="languageType"/>
    <xs:attribute name="script" type="languageType"/>

    <!--fmc copied from event, which is a hack-->
    <xs:attribute name="type">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <!-- Items without content -->
          <xs:enumeration value="unintelligible-word">
            <xs:annotation>
              <xs:documentation> xx</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="unintelligible-word-with-pho">
            <xs:annotation>
              <xs:documentation> yy</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="unintelligible">
            <xs:annotation>
              <xs:documentation> xxx </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="unintelligible-with-pho">
            <xs:annotation>
              <xs:documentation> yyy </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="untranscribed">
            <xs:annotation>
              <xs:documentation> www</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="action">
            <xs:annotation>
              <xs:documentation> 0</xs:documentation>
            </xs:annotation>
          </xs:enumeration>

          <!--fmc items with content; should really move out-->
          <xs:enumeration value="omission">
            <xs:annotation>
              <xs:documentation> 0word</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="incorrect omission">
            <xs:annotation>
              <xs:documentation> 0*word</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="ellipsis">
            <xs:annotation>
              <xs:documentation> 00word</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="fragment">
            <xs:annotation>
              <xs:documentation> &amp;; phonological fragment</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="happening">
            <xs:annotation>
              <xs:documentation> &amp;=; happening, such as sneeze</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>

  </xs:complexType>


  <xs:complexType name="linker" mixed="false">
    <xs:annotation>
      <xs:documentation>utterance initiators or linkers; they indicate the way to fit the current
        utterance with an earlier one, the CHAT conventional symbols are listed
      too</xs:documentation>
    </xs:annotation>
    <xs:attribute name="type">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="quoted utterance next">
            <xs:annotation>
              <xs:documentation> +"</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="quick uptake">
            <xs:annotation>
              <xs:documentation> +^</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="lazy overlap mark">
            <xs:annotation>
              <xs:documentation> +&lt;</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="self completion">
            <xs:annotation>
              <xs:documentation> +,</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="other completion">
            <xs:annotation>
              <xs:documentation> ++</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>


  <!--fmc-->
  <xs:element name="media" type="mediaType"/>

  <xs:complexType name="mediaType">
    <xs:annotation>
      <xs:documentation>a pointer to a selection in a video/audio file</xs:documentation>
    </xs:annotation>
    <xs:attribute name="type">
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="text"/>
          <xs:enumeration value="image"/>
          <xs:enumeration value="audio"/>
          <xs:enumeration value="video"/>
          <xs:enumeration value="application"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="href" type="xs:anyURI"/>
    <xs:attribute name="start" type="xs:float"/>
    <xs:attribute name="end" type="xs:float"/>
    <xs:attribute name="unit">
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="f">
            <xs:annotation>
              <xs:documentation> frame</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="s">
            <xs:annotation>
              <xs:documentation> second</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <!-- MUN added -->
          <xs:enumeration value="ms">
            <xs:annotation>
              <xs:documentation> millisecond</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="b">
            <xs:annotation>
              <xs:documentation> byte</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="c">
            <xs:annotation>
              <xs:documentation> character</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <!-- added 8-30-04 -->
    <xs:attribute name="skip" type="xs:boolean"/>
  </xs:complexType>


  <xs:complexType name="morphemicCompoundType">
    <xs:annotation>
      <xs:documentation> + for mor</xs:documentation>
    </xs:annotation>
  </xs:complexType>

  <xs:complexType name="morphemicPrefixType">
    <xs:annotation>
      <xs:documentation> word#</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="nonemptyStringType"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="morphemicTranslationType">
    <xs:annotation>
      <xs:documentation> =word (English translation)</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="nonemptyStringType"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="morphemic_marker" mixed="false">
    <xs:annotation>
      <xs:documentation> morphemes</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="nonemptyStringType">
        <xs:attribute name="type" use="required">
          <xs:simpleType>
            <xs:restriction base="xs:string">
              <xs:enumeration value="sfx">
                <xs:annotation>
                  <xs:documentation>suffix marker, CHAT equivalent is - </xs:documentation>
                </xs:annotation>
              </xs:enumeration>
              <xs:enumeration value="sfxf">
                <xs:annotation>
                  <xs:documentation> suffix fusion marker, CHAT equivalent is &amp;;
                  </xs:documentation>
                </xs:annotation>
              </xs:enumeration>
              <xs:enumeration value="oafx">
                <xs:annotation>
                  <xs:documentation>omitted affix, CHAT equivalent is -0</xs:documentation>
                </xs:annotation>
              </xs:enumeration>
              <xs:enumeration value="ioafx">
                <xs:annotation>
                  <xs:documentation>incorrectly omitted affix, CHAT equivalent is
                  -0*</xs:documentation>
                </xs:annotation>
              </xs:enumeration>
              <xs:enumeration value="mc">
                <xs:annotation>
                  <xs:documentation> morphological category, CHAT equivalent is :, when used after
                    the stem </xs:documentation>
                </xs:annotation>
              </xs:enumeration>
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>


  <xs:complexType name="participantType" mixed="false">
    <xs:annotation>
      <xs:documentation>the beings along with their characteristics (age, sex...)</xs:documentation>
    </xs:annotation>
    <xs:attribute name="id" type="xs:string" use="required"/>
    <xs:attribute name="role" type="xs:string" use="optional"/>
    <xs:attribute name="name" type="xs:string" use="optional"/>
    <xs:attribute name="age" type="xs:duration" use="optional"/>
    <xs:attribute name="ageTo" type="xs:duration" use="optional"/>
    <xs:attribute name="group" type="xs:string" use="optional"/>
    <xs:attribute name="sex" type="sexType" use="optional"/>
    <xs:attribute name="SES" type="xs:string" use="optional"/>
    <xs:attribute name="education" type="xs:string" use="optional"/>
    <!-- MUN -->
    <xs:attribute name="birthday" type="xs:date" use="optional"/>
    <!--fmc should be lang? -->
    <xs:attribute name="language" type="xs:string" use="optional"/>
  </xs:complexType>


  <!-- begin additions by Eva Mok -->

  <xs:complexType name="entityType" mixed="false">
    <xs:annotation>
      <xs:documentation>other entities present in the environment, namely the objects (e.g.
        furniture, toys) </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="binding" type="bindingType" minOccurs="0" maxOccurs="unbounded"/>
    </xs:choice>
    <xs:attribute name="cat" type="xs:string" use="required"/>
    <xs:attribute name="id" type="xs:string" use="required"/>
  </xs:complexType>

  <xs:complexType name="speechActAnnotationType" mixed="false">
    <xs:annotation>
      <xs:documentation>specifying fillers for speech act annotation</xs:documentation>
    </xs:annotation>
    <xs:attribute name="ref" type="xs:string" use="optional"/>
    <xs:attribute name="value" type="xs:string" use="optional"/>
  </xs:complexType>

  <xs:complexType name="goldstandardConstructionalType" mixed="false"/>
  
  <xs:complexType name="goldstandardSemanticType" mixed="false">
    <xs:annotation>
      <xs:documentation>constructional part of the gold standard annotation for each
      clause</xs:documentation>
    </xs:annotation>
    <xs:sequence maxOccurs="unbounded" minOccurs="0">
        <xs:choice> 
          <xs:element name="temporal_element" type="goldstandardAnnotationType"/>
          <xs:element name="temporal_structure" type="goldstandardAnnotationType"/>
          <xs:element name="topic" type="goldstandardAnnotationType"/>
          <xs:element name="comment" type="goldstandardAnnotationType"/>
          <xs:element name="conditional" type="goldstandardAnnotationType"/>
          <xs:element name="temporal_ordering" type="goldstandardAnnotationType"/>
          <xs:element name="benefaction" type="goldstandardAnnotationType"/>
          <xs:element name="malefaction" type="goldstandardAnnotationType"/>
          <xs:element name="reduplication" type="goldstandardAnnotationType"/>
          <xs:element name="image_schema" type="goldstandardAnnotationType"/>
        </xs:choice>
    </xs:sequence>
  </xs:complexType>
  
  <xs:complexType name="goldstandardAnnotationType" mixed="false">
    <xs:sequence minOccurs="0" maxOccurs="unbounded">
      <xs:element name="binding" type="goldstandardBindingType"/>
    </xs:sequence>
    <xs:attribute name="left" type="xs:nonNegativeInteger" use="optional"/>
    <xs:attribute name="right" type="xs:nonNegativeInteger" use="optional"/>
    <xs:attribute name="value" type="xs:string" use="optional"/>
    <xs:attribute name="ref" type="xs:string" use="optional"/>
    <xs:attribute name="id" type="xs:string" use="optional"/>
    <xs:attribute name="cat" type="xs:string" use="optional"/>
    <xs:attribute name="profiled" type="xs:string" use="optional"/>
  </xs:complexType>
  
  <xs:complexType name="bindingType" mixed="false">
    <xs:annotation>
      <xs:documentation>specifying bindings of fields and values </xs:documentation>
    </xs:annotation>
    <xs:attribute name="source_ref" type="xs:string" use="optional"/>
    <xs:attribute name="field" type="xs:string" use="required"/>
    <!-- unfortunately there is no way to enforce that either value or ref be filled -->
    <xs:attribute name="value" type="xs:string" use="optional"/>
    <xs:attribute name="ref" type="xs:string" use="optional"/>
  </xs:complexType>
  
  <xs:complexType name="goldstandardBindingType" mixed="false">
    <xs:complexContent>
      <xs:extension base="bindingType">
        <xs:attribute name="left" type="xs:nonNegativeInteger" use="optional"/>
        <xs:attribute name="right" type="xs:nonNegativeInteger" use="optional"/>
        <xs:attribute name="subcat" type="xs:string" use="optional"/>
        <xs:attribute name="modified" type="xs:string" use="optional"/>        
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>


  <!-- end additions by Eva Mok -->

  <xs:complexType name="prosodyType">
    <xs:annotation>
      <xs:documentation> stress, blocking etc.</xs:documentation>
    </xs:annotation>
    <xs:sequence minOccurs="0">
      <xs:element name="media" type="mediaType"/>
    </xs:sequence>
    <xs:attribute name="type">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="stress">
            <xs:annotation>
              <xs:documentation> /</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="accented nucleus">
            <xs:annotation>
              <xs:documentation> //</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="contrastive stress">
            <xs:annotation>
              <xs:documentation> /// </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="drawl">
            <xs:annotation>
              <xs:documentation> : </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="pause">
            <xs:annotation>
              <xs:documentation> ^ internal </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="blocking">
            <xs:annotation>
              <xs:documentation> ^ at beginning </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="creaky">
            <xs:annotation>
              <xs:documentation> *text* in CA </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>


  <xs:complexType name="pauseType" mixed="false">
    <xs:annotation>
      <xs:documentation>#, pause between words</xs:documentation>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="a" type="annotationType">
        <xs:annotation>
          <xs:documentation>the place to add research content</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="k" type="markers">
        <xs:annotation>
          <xs:documentation>the place to add research content</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="error" type="errorType"/>
      <xs:element name="overlap" type="overlapType"/>
      <xs:element name="r" type="repetitionType"/>
    </xs:choice>
    <xs:attribute name="fluency" type="fluencyType" use="required"/>
    <xs:attribute name="symbolic-length" type="pauseSymbolicLengthType" use="required"/>
    <xs:attribute name="length" type="pauseNumericLengthType" use="optional"/>
  </xs:complexType>


  <xs:complexType name="repetitionType" mixed="false">
    <xs:annotation>
      <xs:documentation>[x number] in CHAT</xs:documentation>
    </xs:annotation>
    <xs:attribute name="times" type="xs:nonNegativeInteger"/>
  </xs:complexType>


  <xs:complexType name="separatorType" mixed="false">
    <xs:attribute name="type" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="comma"/>
          <xs:enumeration value="semicolon"/>
          <xs:enumeration value="clause delimiter">
            <xs:annotation>
              <xs:documentation> [c] clause-delimiter;</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>


  <xs:complexType name="terminatorType" mixed="false">
    <xs:annotation>
      <xs:documentation>period, question, exclamation; basic utterance terminator; tone
      terminator</xs:documentation>
    </xs:annotation>
    <xs:attribute name="type" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="p"/>
          <xs:enumeration value="q"/>
          <xs:enumeration value="e"/>

          <!-- sterminator -->
          <xs:enumeration value="broken for coding">
            <xs:annotation>
              <xs:documentation> +.</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="trail off">
            <xs:annotation>
              <xs:documentation> +...</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="trail off question">
            <xs:annotation>
              <xs:documentation> +..?</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="question exclamation">
            <xs:annotation>
              <xs:documentation> +!?</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="interruption">
            <xs:annotation>
              <xs:documentation> +/.</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="interruption question">
            <xs:annotation>
              <xs:documentation> +/?</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="self interruption">
            <xs:annotation>
              <xs:documentation> +//.</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="self interruption question">
            <xs:annotation>
              <xs:documentation> +//?</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="quotation next line">
            <xs:annotation>
              <xs:documentation> +"/.</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="quotation precedes">
            <xs:annotation>
              <xs:documentation> +".</xs:documentation>
            </xs:annotation>
          </xs:enumeration>

          <!-- tone -->
          <xs:enumeration value="rising final">
            <xs:annotation>
              <xs:documentation> -?</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="falling final">
            <xs:annotation>
              <xs:documentation> -.</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="final exclamation">
            <xs:annotation>
              <xs:documentation> -!</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="rise fall">
            <xs:annotation>
              <xs:documentation> -'.</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="fall rise">
            <xs:annotation>
              <xs:documentation> -,.</xs:documentation>
            </xs:annotation>
          </xs:enumeration>

        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>


  <xs:complexType name="translation">
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="lang" type="languageType"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>


  <xs:complexType name="utteranceType" mixed="false">
    <xs:sequence>
      <xs:element name="linker" type="linker" minOccurs="0" maxOccurs="unbounded"/>

      <xs:element name="precode" type="precodeType" minOccurs="0" maxOccurs="unbounded"/>

      <xs:choice maxOccurs="unbounded">
        <xs:element name="w" type="wordType"/>
        <xs:element name="g" type="groupType"/>
        <xs:element name="wn" type="wordnetType"/>
        <xs:element name="tone" type="toneType"/>
        <xs:element name="pause" type="pauseType"/>
        <!-- Note allow in the middle -->
        <xs:element ref="media" minOccurs="0"/>
        <xs:element name="freecode" type="freecodeType"/>
        <xs:element name="e" type="eventType">
          <xs:annotation>
            <xs:documentation>a reference to a point/portion of a mute/action signal, e.g. 0
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <!--fmc should really be a separator-->
        <xs:element name="s" type="separatorType">
          <xs:annotation>
            <xs:documentation>semicolon, clause_delimiter [^c]; </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="overlap-point" type="overlapPointType"/>
        <xs:element ref="underline"/>
        <xs:element ref="italic"/>
        <xs:element ref="bold"/>
        <xs:element ref="long-feature"/>
        <xs:element ref="nonvocal"/>
      </xs:choice>

      <!-- allow media at end only if after a terminator -->
      <xs:sequence minOccurs="0">
        <xs:element name="t" type="terminatorType"/>
        <xs:element name="postcode" type="postcodeType" minOccurs="0" maxOccurs="unbounded"/>

        <xs:element ref="media" minOccurs="0"/>

        <!-- Possible tcu pause -->
        <xs:sequence minOccurs="0">
          <xs:element name="pause" type="pauseType"/>
          <xs:element ref="media" minOccurs="0"/>
        </xs:sequence>
      </xs:sequence>

      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <!--fmc why unbounded-->
        <xs:element name="k" type="markers" minOccurs="0" maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation>scoped symbols</xs:documentation>
          </xs:annotation>
        </xs:element>
        <!-- for Brian; fmc overlap all over the place in schema? -->
        <xs:element name="error" type="errorType"/>
        <xs:element name="overlap" type="overlapType"/>
        <xs:element name="r" type="repetitionType"/>

        <!--fmc why unbounded-->
        <xs:element name="a" type="annotationType" minOccurs="0" maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation>the place to add research content</xs:documentation>
          </xs:annotation>
        </xs:element>

        <xs:element name="x" type="translation"/>
        <xs:element name="mor" type="morphemicsType" minOccurs="0"/>
        <xs:element name="trn" type="morphemicsType" minOccurs="0"/>
        <xs:element name="syn" type="syntactic" minOccurs="0"/>
      </xs:choice>
      <!-- MUN: WE ADDED THIS -->
      <xs:element name="ortho" minOccurs="0" maxOccurs="1">
        <xs:complexType>
          <xs:attribute name="ortho" type="xs:string"/>
          <xs:attribute name="type" type="xs:string"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="transcript" type="transcriptType" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="phrases" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="ipa" type="xs:string"/>
            <xs:element name="phrase" type="phraseType" minOccurs="0" maxOccurs="unbounded"/>
          </xs:sequence>
          <xs:attribute name="who" type="xs:string"/>
          <xs:attribute name="type" type="xs:string"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="alignment" type="alignmentType" minOccurs="0" maxOccurs="1"/>

      <!-- //WE ADDED THIS -->
    </xs:sequence>
    <xs:attribute name="date" type="xs:date"/>
    <xs:attribute name="lang" type="languageType"/>
    <xs:attribute name="script" type="languageType"/>
  </xs:complexType>


  <!-- MUN: WE ADDED THIS -->
  <xs:complexType name="transcriptType">
    <xs:sequence>
      <xs:element name="ipa" maxOccurs="unbounded">
        <xs:complexType mixed="true">
          <xs:attribute name="type" type="xs:string"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="who" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="phraseType">
    <xs:sequence>
      <xs:element name="ipa" type="xs:string"/>
      <xs:element name="syllabification" type="syllabificationType" minOccurs="0" maxOccurs="1"/>
    </xs:sequence>
    <xs:attribute name="ortho" type="xs:string"/>
    <xs:attribute name="validated" type="xs:boolean"/>
  </xs:complexType>

  <xs:complexType name="syllabificationType">
    <xs:sequence>
      <xs:element name="syllable" type="syllableType" minOccurs="1" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="syllableType">
    <xs:sequence>
      <xs:element name="constituent" minOccurs="1" maxOccurs="unbounded">
        <xs:complexType mixed="true">
          <xs:sequence>
            <xs:element name="ipa" type="xs:string" minOccurs="1" maxOccurs="1"/>
          </xs:sequence>
          <xs:attribute name="type" type="xs:string" use="required"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="pos" type="xs:integer"/>
    <xs:attribute name="stress" type="xs:integer"/>
  </xs:complexType>

  <xs:complexType name="alignmentType">
    <xs:sequence>
      <!-- MUN: we're going to need a way to do this better.  Right now it doesn't allow
        for multiple ID types (only target and actual).  This will be changed later -->
      <xs:element name="align" minOccurs="1" maxOccurs="unbounded">
        <xs:complexType>
          <xs:attribute name="targetID" type="xs:integer"/>
          <xs:attribute name="actualID" type="xs:integer"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <!-- //WE ADDED THIS -->

  <xs:complexType name="wordnetMarkerType" mixed="false">
    <xs:annotation>
      <xs:documentation>clitic or compound or reduplication markers in wordnet</xs:documentation>
    </xs:annotation>
    <xs:attribute name="type">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="cmp">
            <xs:annotation>
              <xs:documentation> compound, CHAT +</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="cli">
            <xs:annotation>
              <xs:documentation> clitic, CHAT ~</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="red">
            <xs:annotation>
              <xs:documentation> reduplication, CHAT ++</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="hyp">
            <xs:annotation>
              <xs:documentation> hyphen, CHAT -</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="morCliticType" mixed="false">
    <xs:annotation>
      <xs:documentation>clitic separators in morphemics</xs:documentation>
    </xs:annotation>
    <xs:attribute name="type">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="pre">
            <xs:annotation>
              <xs:documentation>preclitic, CHAT $</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="post">
            <xs:annotation>
              <xs:documentation>postclitic, CHAT ~</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>

  <xs:group name="DCelementsGroup">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="title" type="DCelementType"/>
        <xs:element name="creator" type="DCelementType"/>
        <xs:element name="subject" type="DCelementType"/>
        <xs:element name="description" type="DCelementType"/>
        <xs:element name="publisher" type="DCelementType"/>
        <xs:element name="contributor" type="DCelementType"/>
        <xs:element name="date" type="DCelementType"/>
        <xs:element name="type" type="DCelementType"/>
        <xs:element name="format" type="DCelementType"/>
        <xs:element name="identifier" type="DCelementType"/>
        <xs:element name="source" type="DCelementType"/>
        <xs:element name="language" type="DCelementType"/>
        <xs:element name="relation" type="DCelementType"/>
        <xs:element name="coverage" type="DCelementType"/>
        <xs:element name="rights" type="DCelementType"/>
      </xs:choice>
    </xs:sequence>
  </xs:group>


  <xs:complexType name="DCelementType">
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="lang" type="languageType" use="optional"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="tcuType">
    <xs:annotation>
      <xs:documentation>a group of utterances having something in common, usually the
      speaker</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="u" type="speakerUtteranceType" minOccurs="1" maxOccurs="unbounded"/>
      <!--fmc confusing?-->
      <xs:element name="media" type="mediaType" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="who" type="xs:string" use="required"/>
  </xs:complexType>

  <xs:complexType name="speakerUtteranceType">
    <xs:sequence>
      <xs:element name="clause" type="clauseType" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="who" type="xs:string" use="required"/>
    <xs:attribute name="id" type="xs:nonNegativeInteger" use="required"/>
    <!-- MUN added; fmc made optional -->
    <xs:attribute name="type" type="utteranceTypeType" use="optional"/>
  </xs:complexType>

  <xs:complexType name="clauseType">
    <xs:complexContent>
      <xs:extension base="utteranceType"/>
    </xs:complexContent>
  </xs:complexType>

  <!-- MUN -->
  <xs:simpleType name="utteranceTypeType">
    <xs:restriction base="xs:NMTOKEN">
      <xs:enumeration value="phon"/>
      <xs:enumeration value="morpho"/>
    </xs:restriction>
  </xs:simpleType>

  <!--fmc make really extensible-->
  <xs:simpleType name="annotationTypeType">
    <xs:annotation>
      <xs:documentation> these are the (legacy) dependent tiers, %mor line is, now,
        &lt;morphemics&gt; element</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="addressee">
        <xs:annotation>
          <xs:documentation> %add</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="actions">
        <xs:annotation>
          <xs:documentation> %act</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="alternative">
        <xs:annotation>
          <xs:documentation> %alt</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="extension">
        <xs:annotation>
          <xs:documentation> %cod; general purpose coding</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="cohesion">
        <xs:annotation>
          <xs:documentation> %coh; cohesion tier</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="comments">
        <xs:annotation>
          <xs:documentation> %com;[% text]; comments by investigator</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="vernacular">
        <xs:annotation>
          <xs:documentation> %com;[% text]; comments by investigator</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="speech act">
        <xs:annotation>
          <xs:documentation> %com;[% text]; comments by investigator</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="gold standard">
        <xs:annotation>
          <xs:documentation> %com;[% text]; comments by investigator</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <!-- Brian said rid
      <xs:enumeration value="completion">
        <xs:annotation>
          <xs:documentation> [0 text]; an omitted word</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
-->
      <xs:enumeration value="english translation">
        <xs:annotation>
          <xs:documentation> %eng</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="errcoding">
        <xs:annotation>
          <xs:documentation> %err; error coding</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="excluded material">
        <xs:annotation>
          <xs:documentation>[%exc ...]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="explanation">
        <xs:annotation>
          <xs:documentation> %exp; [= text]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="flow">
        <xs:annotation>
          <xs:documentation> %flo</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="facial">
        <xs:annotation>
          <xs:documentation> %fac</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="target gloss">
        <xs:annotation>
          <xs:documentation> %gls</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="gesture">
        <xs:annotation>
          <xs:documentation> %gpx</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="intonation">
        <xs:annotation>
          <xs:documentation> %int</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="language">
        <xs:annotation>
          <xs:documentation> %lan</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="orthography">
        <xs:annotation>
          <xs:documentation> %ort</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="paralinguistics">
        <xs:annotation>
          <xs:documentation> %par:</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="pause">
        <xs:annotation>
          <xs:documentation> %:</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="phonetic">
        <xs:annotation>
          <xs:documentation> %pho:</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <!-- Brian -->
      <xs:enumeration value="phonetic old">
        <xs:annotation>
          <xs:documentation> %pht:</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="phonomodel">
        <xs:annotation>
          <xs:documentation> %mod:</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="replacement">
        <xs:annotation>
          <xs:documentation> [: text]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SALT">
        <xs:annotation>
          <xs:documentation> %def; on the main line, not recommended</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="situation">
        <xs:annotation>
          <xs:documentation> %sit</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="simple syntax">
        <xs:annotation>
          <xs:documentation> %ssy</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="speech act">
        <xs:annotation>
          <xs:documentation> %spa</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="spelling">
        <xs:annotation>
          <xs:documentation> %spe</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="time stamp">
        <xs:annotation>
          <xs:documentation> %tim</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="extension">
        <xs:annotation>
          <xs:documentation> arbitrary annotations, intended as an extension
          mechanism</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="tone markings">
        <xs:annotation>
          <xs:documentation> %ton</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="romanization">
        <xs:annotation>
          <xs:documentation> %rom</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="standard for dialect">
        <xs:annotation>
          <xs:documentation> %sdi</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="standard for child">
        <xs:annotation>
          <xs:documentation> %sch</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="standard for unclear source">
        <xs:annotation>
          <xs:documentation> %sxx</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="sexType">
    <xs:restriction base="xs:NMTOKEN">
      <xs:enumeration value="male"/>
      <xs:enumeration value="female"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="fluencyType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="fluent">
        <xs:annotation>
          <xs:documentation>No symbol</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="disfluent">
        <xs:annotation>
          <xs:documentation>d</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="pauseSymbolicLengthType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="simple">
        <xs:annotation>
          <xs:documentation>#</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="long">
        <xs:annotation>
          <xs:documentation>##</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="very long">
        <xs:annotation>
          <xs:documentation>###</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="pauseNumericLengthType">
    <xs:annotation>
      <xs:documentation>fmc should change to xs:duration</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:float"/>
  </xs:simpleType>

  <xs:simpleType name="beginEndType">
    <xs:annotation>
      <xs:documentation>For use for delimited material. A workaround for lack of overlapping
        elements in XML. </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="begin">
        <xs:annotation>
          <xs:documentation>Begin delimited material</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="end">
        <xs:annotation>
          <xs:documentation>End delimited material</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="beginEndSimpleType">
    <xs:annotation>
      <xs:documentation>For use for delimited material. A workaround for lack of overlapping
        elements in XML. </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="begin">
        <xs:annotation>
          <xs:documentation>Begin delimited material</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="end">
        <xs:annotation>
          <xs:documentation>End delimited material</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="simple">
        <xs:annotation>
          <xs:documentation>Begin and end delimited material (degenerate case)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:element name="underline">
    <xs:annotation>
      <xs:documentation>Underline arbitrary content</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:string">
          <xs:attribute name="type" type="beginEndType" use="required"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:element name="italic">
    <xs:annotation>
      <xs:documentation>Italic arbitrary content</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:string">
          <xs:attribute name="type" type="beginEndType" use="required"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:element name="bold">
    <xs:annotation>
      <xs:documentation>Bold arbitrary content</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:string">
          <xs:attribute name="type" type="beginEndType" use="required"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:element name="long-feature">
    <xs:annotation>
      <xs:documentation>Long feature &lt;TAG material TAG&gt;for Santa Barbara; other
        begin/end features</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:string">
          <xs:attribute name="type" type="beginEndType" use="required"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:element name="nonvocal">
    <xs:annotation>
      <xs:documentation>Nonvocal &lt;&lt;TAG material TAG&gt;&gt;for Santa
      Barbara</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:string">
          <xs:attribute name="type" type="beginEndSimpleType" use="required"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

</xs:schema>
